export const SCXQ2_ES_V1_EBNF = "(* =========================================================\n   SCXQ2-ES v1 Surface Grammar (Expression-Only Subset)\n   Target: Elasticsearch Painless (script_score, script_fields, aggs)\n   ========================================================= *)\n\nprogram         ::= ws? expr ws? ;\n\nexpr            ::= ternary ;\n\nternary         ::= logical_or ( ws? \"?\" ws? expr ws? \":\" ws? expr )? ;\n\nlogical_or      ::= logical_and ( ws? ( \"|\" | \"||\" ) ws? logical_and )* ;\nlogical_and     ::= equality    ( ws? ( \"&\" | \"&&\" ) ws? equality )* ;\n\nequality        ::= relational  ( ws? ( \"==\" | \"!=\" ) ws? relational )* ;\nrelational      ::= additive    ( ws? ( \"<=\" | \"<\" | \">=\" | \">\" ) ws? additive )* ;\n\nadditive        ::= multiplicative ( ws? ( \"+\" | \"-\" ) ws? multiplicative )* ;\nmultiplicative  ::= unary          ( ws? ( \"*\" | \"/\" | \"%\" ) ws? unary )* ;\n\nunary           ::= ( ws? ( \"!\" | \"-\" | \"+\" ) ws? )* postfix ;\n\npostfix         ::= primary ( ws? \"??\" ws? primary )? ;\n(* NOTE: v1 coalesce is only one level: a ?? b.\n         Nested coalesce is allowed by recursion:\n         primary can include parenthesized expr containing ?? again. *)\n\nprimary         ::= number\n                 | string\n                 | bool\n                 | null\n                 | score_ref\n                 | params_ref\n                 | doc_ref\n                 | call\n                 | \"(\" ws? expr ws? \")\" ;\n\nscore_ref       ::= \"_score\" ;\n\nparams_ref      ::= \"params\" \".\" ident ;\n\ndoc_ref         ::= \"doc\" \"[\" string \"]\" ( \".\" \"value\" | \".\" \"size\" | \".\" \"empty\" )? ;\n(* Strongly recommended: do NOT use doc_ref directly in v1 scripts.\n   Prefer @v('field') and @exists('field') for safety/consistency. *)\n\ncall            ::= \"@\" ident \"(\" ws? args? ws? \")\" ;\nargs            ::= expr ( ws? \",\" ws? expr )* ;\n\nnumber          ::= int ( \".\" digit+ )? | \".\" digit+ ;\nint             ::= digit+ ;\n\nstring          ::= \"'\" str_char* \"'\" | \"\\\"\" dstr_char* \"\\\"\" ;\n\nbool            ::= \"true\" | \"false\" ;\nnull            ::= \"null\" ;\n\nident           ::= ident_start ident_rest* ;\nident_start     ::= letter | \"_\" ;\nident_rest      ::= letter | digit | \"_\" ;\n\ndigit           ::= \"0\"..\"9\" ;\nletter          ::= \"A\"..\"Z\" | \"a\"..\"z\" ;\n\nstr_char        ::= escape | ( any_char_except_single_quote_or_backslash ) ;\ndstr_char       ::= escape | ( any_char_except_double_quote_or_backslash ) ;\nescape          ::= \"\\\\\" ( \"\\\\\" | \"'\" | \"\\\"\" | \"n\" | \"r\" | \"t\" ) ;\n\nws              ::= ( \" \" | \"\\t\" | \"\\n\" | \"\\r\" )+ ;\n";
